package io.github.burakkaygusuz.model;

/**
 * Enumeration of different vulnerability types. Each type represents a specific security
 * vulnerability that can be detected during web application security scanning.
 */
public enum VulnerabilityType {

  /**
   * SQL Injection vulnerability - allows attackers to interfere with the queries that an
   * application makes to its database.
   */
  SQL_INJECTION(
      "SQL Injection",
      "Database queries vulnerable to malicious SQL code injection",
      Severity.CRITICAL.getName()),

  /**
   * Cross-Site Scripting (XSS) vulnerability - allows attackers to inject malicious scripts into
   * web pages viewed by other users.
   */
  CROSS_SITE_SCRIPTING(
      "Cross-Site Scripting (XSS)",
      "Web pages vulnerable to malicious script injection",
      Severity.HIGH.getName()),

  /** Cross-Site Request Forgery without token - forms submitted without CSRF protection. */
  NO_CSRF_TOKEN(
      "No CSRF Token", "Form submitted without CSRF token protection", Severity.HIGH.getName()),

  /** Cross-Site Request Forgery with invalid token - forms submitted with invalid CSRF tokens. */
  INVALID_CSRF_TOKEN(
      "Invalid CSRF Token", "Form submitted with invalid CSRF token", Severity.HIGH.getName()),

  /**
   * Cross-Site Request Forgery with reused token - forms submitted with previously used CSRF
   * tokens.
   */
  REUSED_CSRF_TOKEN(
      "Reused CSRF Token", "Form submitted with reused CSRF token", Severity.HIGH.getName()),

  /** Cross-Site Request Forgery with expired token - forms submitted with expired CSRF tokens. */
  EXPIRED_CSRF_TOKEN(
      "Expired CSRF Token", "Form submitted with expired CSRF token", Severity.MEDIUM.getName()),

  /** Weak Referer header validation - insufficient validation of HTTP Referer header. */
  WEAK_REFERER_VALIDATION(
      "Weak Referer Validation",
      "Insufficient Referer header validation",
      Severity.MEDIUM.getName()),

  /** Sensitive Information Exposure - application exposes sensitive data. */
  SENSITIVE_INFO_EXPOSURE(
      "Sensitive Information Exposure",
      "Application exposes sensitive information",
      Severity.MEDIUM.getName()),

  /** Missing SameSite cookie attribute - session cookies lack SameSite protection. */
  MISSING_SAMESITE_COOKIE(
      "Missing SameSite Cookie",
      "Session cookies lack SameSite attribute",
      Severity.MEDIUM.getName()),

  /** Unknown or unclassified vulnerability type. */
  UNKNOWN("Unknown", "Unclassified vulnerability type", Severity.LOW.getName());

  private final String displayName;
  private final String description;
  private final String severity;

  VulnerabilityType(String displayName, String description, String severity) {
    this.displayName = displayName;
    this.description = description;
    this.severity = severity;
  }

  /**
   * Gets the human-readable display name for this vulnerability type.
   *
   * @return display name
   */
  public String getDisplayName() {
    return displayName;
  }

  /**
   * Gets a detailed description of this vulnerability type.
   *
   * @return description
   */
  public String getDescription() {
    return description;
  }

  /**
   * Gets the severity level for this vulnerability type.
   *
   * @return severity level (LOW, MEDIUM, HIGH, CRITICAL)
   */
  public String getSeverity() {
    return severity;
  }

  /**
   * Gets the numeric severity score for this vulnerability type.
   *
   * @return severity score (1-4)
   */
  public int getSeverityScore() {
    Severity severityEnum = Severity.fromName(severity);
    return severityEnum != null ? severityEnum.getScore() : 0;
  }

  /**
   * Finds the vulnerability type by its display name.
   *
   * @param displayName the display name to search for
   * @return the matching vulnerability type, or UNKNOWN if not found
   */
  public static VulnerabilityType fromDisplayName(String displayName) {
    if (displayName == null) {
      return UNKNOWN;
    }

    for (VulnerabilityType type : values()) {
      if (type.displayName.equals(displayName)) {
        return type;
      }
    }
    return UNKNOWN;
  }

  /**
   * Gets the detector type category for this vulnerability type. Used by DetectorFactory to
   * determine which detector to create.
   *
   * @return the detector type category
   */
  public DetectorType getDetectorType() {
    return switch (this) {
      case SQL_INJECTION -> DetectorType.SQL_INJECTION;
      case CROSS_SITE_SCRIPTING -> DetectorType.XSS;
      case NO_CSRF_TOKEN,
          INVALID_CSRF_TOKEN,
          REUSED_CSRF_TOKEN,
          EXPIRED_CSRF_TOKEN,
          WEAK_REFERER_VALIDATION,
          MISSING_SAMESITE_COOKIE ->
          DetectorType.CSRF;
      case SENSITIVE_INFO_EXPOSURE -> DetectorType.SENSITIVE_INFO;
      default -> DetectorType.UNKNOWN;
    };
  }

  /** Enumeration of detector type categories. */
  public enum DetectorType {
    SQL_INJECTION("sql", "sql_injection"),
    XSS("xss", "cross_site_scripting"),
    SENSITIVE_INFO("sensitive", "sensitive_info"),
    CSRF("csrf", "cross_site_request_forgery"),
    UNKNOWN("unknown");

    private final String[] aliases;

    DetectorType(String... aliases) {
      this.aliases = aliases;
    }

    public String[] getAliases() {
      return aliases;
    }

    /**
     * Finds detector type by string input (supports aliases).
     *
     * @param input the input string
     * @return matching detector type or UNKNOWN
     */
    public static DetectorType fromString(String input) {
      if (input == null || input.trim().isEmpty()) {
        return UNKNOWN;
      }

      String normalized = input.toLowerCase().trim();
      for (DetectorType type : values()) {
        for (String alias : type.aliases) {
          if (alias.equals(normalized)) {
            return type;
          }
        }
      }
      return UNKNOWN;
    }
  }
}
